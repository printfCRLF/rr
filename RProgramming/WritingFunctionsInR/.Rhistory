map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    map(n, rnorm) } map1
map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map1
map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map1()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map1()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map_over_two_arguments <- function() {     # Initialize n
    n <- list(5, 10, 20)
    # Create a list mu containing the values: 1, 5, and 10
    mu <- list(1, 5, 10)
    # Edit to call map2() on n and mu with rnorm() to simulate three samples
    result <- map2(n, mu, rnorm)     print(result) } #map1() map_over_two_arguments()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map_over_two_arguments <- function() {     # Initialize n
    n <- list(5, 10, 20)
    # Create a list mu containing the values: 1, 5, and 10
    mu <- list(1, 5, 10)
    # Edit to call map2() on n and mu with rnorm() to simulate three samples
    result <- map2(n, mu, rnorm)     print(result) } #map1() map_over_two_arguments()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map_over_two_arguments <- function() {     # Initialize n
    n <- list(5, 10, 20)
    # Create a list mu containing the values: 1, 5, and 10
    mu <- list(1, 5, 10)
    # Edit to call map2() on n and mu with rnorm() to simulate three samples
    result <- map2(n, mu, rnorm)     print(result) } map_over_multiple_arguments <- function() {     n <- list(5, 10, 20)     means <- list(1, 5, 10)     sd <- list(0.1, 1, 0.1)     result <- pmap(list(n, means, st), rnorm)     print(result) } #map1() #map_over_two_arguments() map_over_multiple_arguments()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20
    n <- list(5, 10, 20)
    # Call map() on n with rnorm() to simulate three samples
    result <- map(n, rnorm)     print(result) } map_over_two_arguments <- function() {     # Initialize n
    n <- list(5, 10, 20)
    # Create a list mu containing the values: 1, 5, and 10
    mu <- list(1, 5, 10)
    # Edit to call map2() on n and mu with rnorm() to simulate three samples
    result <- map2(n, mu, rnorm)     print(result) } map_over_multiple_arguments <- function() {     n <- list(5, 10, 20)     means <- list(1, 5, 10)     sd <- list(0.1, 1, 0.1)     result <- pmap(list(n, means, sd), rnorm)     print(result) } #map1() #map_over_two_arguments() map_over_multiple_arguments()
library(purrr) map1 <- function() {     # Create a list n containing the values: 5, 10, and 20     n <- list(5, 10, 20)     # Call map() on n with rnorm() to simulate three samples     result <- map(n, rnorm)     print(result) } map_over_two_arguments <- function() {     # Initialize n     n <- list(5, 10, 20)     # Create a list mu containing the values: 1, 5, and 10     mu <- list(1, 5, 10)     # Edit to call map2() on n and mu with rnorm() to simulate three samples     result <- map2(n, mu, rnorm)     print(result) } map_over_multiple_arguments <- function() {     n <- list(5, 10, 20)     means <- list(1, 5, 10)     sd <- list(0.1, 1, 0.1)     result <- pmap(list(n, means, sd), rnorm)     print(result)     pmap(list(mean = mu, n = n, sd = sd), rnorm) } mapping_over_functions <- function() {     # Define list of functions     funs <- list("rnorm", "runif", "rexp")     # Parameter list for rnorm()     rnorm_params <- list(mean = 10)     # Add a min element with value 0 and max element with value 5     runif_params <- list(min = 0, max = 5)     # Add a rate element with value 5     rexp_params <- list(rate = 5)     # Define params for each function     params <- list(       rnorm_params,       runif_params,       rexp_params     )     # Call invoke_map() on funs supplying params and setting n to 5     invoke_map(funs, params, n = 5) } #map1() #map_over_two_arguments() #map_over_multiple_arguments() mapping_over_functions()
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/4_AdvancedInputsAndOutputs/3_maps_with_side_effects.R", echo = TRUE, encoding = "gb2312")
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/4_AdvancedInputsAndOutputs/3_maps_with_side_effects.R", echo = TRUE, encoding = "gb2312")
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/4_AdvancedInputsAndOutputs/3_maps_with_side_effects.R", echo = TRUE, encoding = "gb2312")
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/4_AdvancedInputsAndOutputs/3_maps_with_side_effects.R", echo = TRUE, encoding = "gb2312")
library(purrr) funs <- list(Normal = "rnorm", Uniform = "runif", Exp = "rexp") params <- list(         Normal = list(mean = 10),         Uniform = list(min = 0, max = 5),         Exp = list(rate = 5)     ) sims <- invoke_map(funs, params, n = 50) walk_example <- function(sims) {     walk(sims, hist) }
walking_over_two_or_more_arguments <- function(sim) {
    # Replace "Sturges" with reasonable breaks for each sample
    breaks_list <- list(
      Normal = seq(6, 16, 0.5),
      Uniform = seq(0, 5, 0.25),
      Exp = seq(0, 1.5, 0.1)
    )
    # Use walk2() to make histograms with the right breaks
    walk2(sims, breaks_list, hist)
}
find_breaks <- function(x) {
    rng <- range(x, na.rm = TRUE)
    seq(rng[1], rng[2], length.out = 30)
}
nice_breaks <- function(sim) {
    # Call find_breaks() on sims[[1]]
    find_breaks(sims[[1]])
    # Use map() to iterate find_breaks() over sims: nice_breaks
    nice_breaks <- map(sims, find_breaks)
    # Use nice_breaks as the second argument to walk2()
    walk2(sims, nice_breaks, hist)
}
pwalk_example <- function() {
    # Increase sample size to 1000
    sims <- invoke_map(funs, params, n = 1000)
    # Compute nice_breaks (don't change this)
    nice_breaks <- map(sims, find_breaks)
    # Create a vector nice_titles
    nice_titles <- list("Normal(10, 1)", "Uniform(0, 5)", "Exp(5)")
    # Use pwalk() instead of walk2()
    pwalk(list(x = sims, breaks = nice_breaks, main = nice_titles), hist, xlab = "")
}
#walk_example()
#walking_over_two_or_more_arguments()
pwalk_example()
library(purrr) funs <- list(Normal = "rnorm", Uniform = "runif", Exp = "rexp") params <- list(         Normal = list(mean = 10),         Uniform = list(min = 0, max = 5),         Exp = list(rate = 5)     ) sims <- invoke_map(funs, params, n = 50) walk_example <- function(sims) {     walk(sims, hist) }
walking_over_two_or_more_arguments <- function(sim) {
    # Replace "Sturges" with reasonable breaks for each sample
    breaks_list <- list(
      Normal = seq(6, 16, 0.5),
      Uniform = seq(0, 5, 0.25),
      Exp = seq(0, 1.5, 0.1)
    )
    # Use walk2() to make histograms with the right breaks
    walk2(sims, breaks_list, hist)
}
find_breaks <- function(x) {
    rng <- range(x, na.rm = TRUE)
    seq(rng[1], rng[2], length.out = 30)
}
nice_breaks <- function(sim) {
    # Call find_breaks() on sims[[1]]
    find_breaks(sims[[1]])
    # Use map() to iterate find_breaks() over sims: nice_breaks
    nice_breaks <- map(sims, find_breaks)
    # Use nice_breaks as the second argument to walk2()
    walk2(sims, nice_breaks, hist)
}
pwalk_example <- function() {
    # Increase sample size to 1000
    sims <- invoke_map(funs, params, n = 1000)
    # Compute nice_breaks (don't change this)
    nice_breaks <- map(sims, find_breaks)
    # Create a vector nice_titles
    nice_titles <- list("Normal(10, 1)", "Uniform(0, 5)", "Exp(5)")
    # Use pwalk() instead of walk2()
    pwalk(list(x = sims, breaks = nice_breaks, main = nice_titles), hist, xlab = "")
}
walking_with_pipes <- function() {
    sims %>%
    walk(hist) %>% map(summary)
}
#walk_example()
#walking_over_two_or_more_arguments()
#pwalk_example()
walking_with_pipes()
an_error_is_better_than_a_surprise <- function() {     # Define troublesome x and y
    x <- c(NA, NA, NA)
    y <- c(1, NA, NA, NA)
    both_na <- function(x, y) {
        # Add stopifnot() to check length of x and y
        stopifnot(length(x) == length(y))
        sum(is.na(x) & is.na(y))
    }
    # Call both_na() on x and y     both_na(x, y) } an_error_is_better_than_a_surprise();
an_error_is_better_than_a_surprise <- function() {     # Define troublesome x and y
    x <- c(NA, NA, NA)
    y <- c(1, NA, NA, NA)
    both_na <- function(x, y) {
        # Add stopifnot() to check length of x and y
        stopifnot(length(x) == length(y))
        sum(is.na(x) & is.na(y))
    }
    # Call both_na() on x and y     both_na(x, y) } an_informative_error_is_even_better <- function() {     # Define troublesome x and y
    x <- c(NA, NA, NA)
    y <- c(1, NA, NA, NA)
    both_na <- function(x, y) {
        # Replace condition with logical
        if (length(x) != length(y)) {
            # Replace "Error" with better message
            stop("x and y must have the same length", call. = FALSE)
        }
        sum(is.na(x) & is.na(y))
    }
    # Call both_na() 
    both_na(x, y) } #an_error_is_better_than_a_surprise() an_informative_error_is_even_better()
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/5_robust_functions/2_unstable_types_video.R", echo = TRUE, encoding = "gb2312")
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/5_robust_functions/2_unstable_types_video.R", echo = TRUE, encoding = "gb2312")
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/5_robust_functions/2_unstable_types_video.R", echo = TRUE, encoding = "gb2312")
unstable_types <- function() {     df <- data.frame(z = 1:3, y = 2:4)     result <- str(df[1,])     print(result)     df <- data.frame(z = 1:3)     result <- str(df[1,])     print(result) } df <- data.frame(         a = 1L,         b = 1.5,         y = Sys.time(),         z = ordered(1)     ) using_purrr <- function(df) {     # sapply calls     A <- sapply(df[1:4], class)     B <- sapply(df[3:4], class)     C <- sapply(df[1:2], class)     # Demonstrate type inconsistency     str(A)     str(B)     str(C)     # Use map() to define X, Y and Z     X <- map(df[1:4], class)     Y <- map(df[3:4], class)     Z <- map(df[1:2], class)     # Use str() to check type consistency     str(X)     str(Y)     str(Z) } a_type_consistent_solution <- function(df) {     col_classes <- function(df) {
        # Assign list output to class_list
        class_list <- map(df, class)
        # Use map_chr() to extract first element in class_list
        map_chr(class_list, 1)
    }
    # Check that our new function is type consistent
    df %>% col_classes() %>% str()
    df[3:4] %>% col_classes() %>% str()
    df[1:2] %>% col_classes() %>% str() } #unstable_types() #using_purrr() a_type_consistent_solution()
unstable_types <- function() {     df <- data.frame(z = 1:3, y = 2:4)     result <- str(df[1,])     print(result)     df <- data.frame(z = 1:3)     result <- str(df[1,])     print(result) } df <- data.frame(         a = 1L,         b = 1.5,         y = Sys.time(),         z = ordered(1)     ) using_purrr <- function(df) {     # sapply calls     A <- sapply(df[1:4], class)     B <- sapply(df[3:4], class)     C <- sapply(df[1:2], class)     # Demonstrate type inconsistency     str(A)     str(B)     str(C)     # Use map() to define X, Y and Z     X <- map(df[1:4], class)     Y <- map(df[3:4], class)     Z <- map(df[1:2], class)     # Use str() to check type consistency     str(X)     str(Y)     str(Z) } a_type_consistent_solution <- function(df) {     col_classes <- function(df) {
        # Assign list output to class_list
        class_list <- map(df, class)
        # Use map_chr() to extract first element in class_list
        map_chr(class_list, 1)
    }
    # Check that our new function is type consistent
    df %>% col_classes() %>% str()
    df[3:4] %>% col_classes() %>% str()
    df[1:2] %>% col_classes() %>% str() } #unstable_types() #using_purrr(df) a_type_consistent_solution(df)
source("E:/IT/github/rr/RProgramming/WritingFunctionsInR/5_robust_functions/2_unstable_types_video.R", echo = TRUE, encoding = "gb2312")
a_hidden_dependence <- function() {
    # This is the default behavior
    options(stringsAsFactors = TRUE)
    # Read in the swimming_pools.csv to pools
    pools <- read.csv("swimming_pools.csv")
    # Examine the structure of pools
    print(str(pools))
    # Change the global stringsAsFactors option to FALSE
    options(stringsAsFactors = FALSE)
    # Read in the swimming_pools.csv to pools2
    pools2 <- read.csv("swimming_pools.csv")
    # Examine the structure of pools2
    print(str(pools2))
}
a_hidden_dependence()
